 #include "pch.h"
 #include "misc.h"
 #include "des.h"

 NAMESPACE_BEGIN(CryptoPP)

 typedef BlockGetAndPut<word32, BigEndian> Block;

 static inline void IPERM(word32 &left, word32 &right)
 {
     word32 work;

     right = rotlConstant<4>(right);
     work = (left ^ right) & 0xf0f0f0f0;
     left ^= work;
     right = rotrConstant<20>(right^work);
     work = (left ^ right) & 0xffff0000;
     left ^= work;
     right = rotrConstant<18>(right^work);
     work = (left ^ right) & 0x33333333;
     left ^= work;
     right = rotrConstant<6>(right^work);
     work = (left ^ right) & 0x00ff00ff;
     left ^= work;
     right = rotlConstant<9>(right^work);
     work = (left ^ right) & 0xaaaaaaaa;
     left = rotlConstant<1>(left^work);
     right ^= work;
 }

 static inline void FPERM(word32 &left, word32 &right)
 {
     word32 work;

     right = rotrConstant<1>(right);
     work = (left ^ right) & 0xaaaaaaaa;
     right ^= work;
     left = rotrConstant<9>(left^work);
     work = (left ^ right) & 0x00ff00ff;
     right ^= work;
     left = rotlConstant<6>(left^work);
     work = (left ^ right) & 0x33333333;
     right ^= work;
     left = rotlConstant<18>(left^work);
     work = (left ^ right) & 0xffff0000;
     right ^= work;
     left = rotlConstant<20>(left^work);
     work = (left ^ right) & 0xf0f0f0f0;
     right ^= work;
     left = rotrConstant<4>(left^work);
 }

 void DES::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)
 {
     AssertValidKeyLength(length);
     RawSetKey(GetCipherDirection(), userKey);
 }

 #ifndef CRYPTOPP_IMPORTS

 namespace {
     const byte pc1[] = {
        57, 49, 41, 33, 25, 17,  9,
         1, 58, 50, 42, 34, 26, 18,
        10,  2, 59, 51, 43, 35, 27,
        19, 11,  3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
         7, 62, 54, 46, 38, 30, 22,
        14,  6, 61, 53, 45, 37, 29,
        21, 13,  5, 28, 20, 12,  4
     };
 }

 namespace {
     const byte totrot[] = {
        1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28
     };
 }

 namespace {
     const byte pc2[] = {
        14, 17, 11, 24,  1,  5,
         3, 28, 15,  6, 21, 10,
        23, 19, 12,  4, 26,  8,
        16,  7, 27, 20, 13,  2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
     };
 }

 namespace {
     const int bytebit[] = {
        0200,0100,040,020,010,04,02,01
     };
 }

 void RawDES::RawSetKey(CipherDir dir, const byte *key)
 {
     SecByteBlock buffer(56+56+8);
     byte *const pc1m=buffer;
     byte *const pcr=pc1m+56;
     byte *const ks=pcr+56;
     int i,j,l;
     int m;

     for (j=0; j<56; j++) {
         l=pc1[j]-1;
         m = l & 07;
         pc1m[j]=(key[l>>3] & bytebit[m]) ? 1 : 0;
     }
     for (i=0; i<16; i++) {
         memset(ks,0,8);
         for (j=0; j<56; j++)
             pcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];

         for (j=0; j<48; j++){
             if (pcr[pc2[j]-1]){
                 l= j % 6;
                 ks[j/6] |= bytebit[l] >> 2;
             }
         }

         k[2*i] = ((word32)ks[0] << 24)
             | ((word32)ks[2] << 16)
             | ((word32)ks[4] << 8)
             | ((word32)ks[6]);
         k[2*i+1] = ((word32)ks[1] << 24)
             | ((word32)ks[3] << 16)
             | ((word32)ks[5] << 8)
             | ((word32)ks[7]);
     }

     if (dir==DECRYPTION)
         for (i=0; i<16; i+=2)
         {
             std::swap(k[i], k[32-2-i]);
             std::swap(k[i+1], k[32-1-i]);
         }
 }

 void RawDES::RawProcessBlock(word32 &l_, word32 &r_) const
 {
     word32 l = l_, r = r_;
     const word32 *kptr=k;

     for (unsigned i=0; i<8; i++)
     {
         word32 work = rotrConstant<4>(r) ^ kptr[4 * i + 0];
         l ^= Spbox[6][(work) & 0x3f]
           ^ Spbox[4][(work >> 8) & 0x3f]
           ^ Spbox[2][(work >> 16) & 0x3f]
           ^ Spbox[0][(work >> 24) & 0x3f];
         work = r ^ kptr[4*i+1];
         l ^= Spbox[7][(work) & 0x3f]
           ^ Spbox[5][(work >> 8) & 0x3f]
           ^ Spbox[3][(work >> 16) & 0x3f]
           ^ Spbox[1][(work >> 24) & 0x3f];

         work = rotrConstant<4>(l) ^ kptr[4 * i + 2];
         r ^= Spbox[6][(work) & 0x3f]
           ^ Spbox[4][(work >> 8) & 0x3f]
           ^ Spbox[2][(work >> 16) & 0x3f]
           ^ Spbox[0][(work >> 24) & 0x3f];
         work = l ^ kptr[4*i+3];
         r ^= Spbox[7][(work) & 0x3f]
           ^ Spbox[5][(work >> 8) & 0x3f]
           ^ Spbox[3][(work >> 16) & 0x3f]
           ^ Spbox[1][(work >> 24) & 0x3f];
     }

     l_ = l; r_ = r;
 }

 void DES_EDE2::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)
 {
     AssertValidKeyLength(length);
     m_des1.RawSetKey(GetCipherDirection(), userKey);
     m_des2.RawSetKey(ReverseCipherDir(GetCipherDirection()), userKey+8);
 }

 void DES_EDE2::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
 {
     word32 l,r;
     Block::Get(inBlock)(l)(r);
     IPERM(l,r);
     m_des1.RawProcessBlock(l, r);
     m_des2.RawProcessBlock(r, l);
     m_des1.RawProcessBlock(l, r);
     FPERM(l,r);
     Block::Put(xorBlock, outBlock)(r)(l);
 }

 void DES_EDE3::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &)
 {
     AssertValidKeyLength(length);
     m_des1.RawSetKey(GetCipherDirection(), userKey + (IsForwardTransformation() ? 0 : 16));
     m_des2.RawSetKey(ReverseCipherDir(GetCipherDirection()), userKey + 8);
     m_des3.RawSetKey(GetCipherDirection(), userKey + (IsForwardTransformation() ? 16 : 0));
 }

 void DES_EDE3::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
 {
     word32 l,r;
     Block::Get(inBlock)(l)(r);
     IPERM(l,r);
     m_des1.RawProcessBlock(l, r);
     m_des2.RawProcessBlock(r, l);
     m_des3.RawProcessBlock(l, r);
     FPERM(l,r);
     Block::Put(xorBlock, outBlock)(r)(l);
 }

 #endif

 static inline bool CheckParity(byte b)
 {
     unsigned int a = b ^ (b >> 4);
     return ((a ^ (a>>1) ^ (a>>2) ^ (a>>3)) & 1) == 1;
 }

 bool DES::CheckKeyParityBits(const byte *key)
 {
     for (unsigned int i=0; i<8; i++)
         if (!CheckParity(key[i]))
             return false;
     return true;
 }

 void DES::CorrectKeyParityBits(byte *key)
 {
     for (unsigned int i=0; i<8; i++)
         if (!CheckParity(key[i]))
             key[i] ^= 1;
 }

 void DES::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
 {
     word32 l,r;
     Block::Get(inBlock)(l)(r);
     IPERM(l,r);
     RawProcessBlock(l, r);
     FPERM(l,r);
     Block::Put(xorBlock, outBlock)(r)(l);
 }

 void DES_XEX3::Base::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &)
 {
     AssertValidKeyLength(length);

     if (!m_des.get())
         m_des.reset(new DES::Encryption);

     memcpy(m_x1, key + (IsForwardTransformation() ? 0 : 16), BLOCKSIZE);
     m_des->RawSetKey(GetCipherDirection(), key + 8);
     memcpy(m_x3, key + (IsForwardTransformation() ? 16 : 0), BLOCKSIZE);
 }

 void DES_XEX3::Base::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const
 {
     xorbuf(outBlock, inBlock, m_x1, BLOCKSIZE);
     m_des->ProcessAndXorBlock(outBlock, xorBlock, outBlock);
     xorbuf(outBlock, m_x3, BLOCKSIZE);
 }

 NAMESPACE_END